        - # RK4 is a function which performs one step of the Runge-Kutta 4 ray tracing
        - #
        - # EndPoint = RK4(StartPoint, GradientVolume, StepSize);
        - #
        - # inputs :
        - #      StartPoint: 2D or 3D location in vectorfield
        - #      GradientVolume: Vectorfield
        - #      Stepsize : The stepsize
        - #
        - # outputs :
        - #      EndPoint : The new location (zero if outside image)
        - #
        - # Function is written by D.Kroon University of Twente (July 2008)
        - # Port from C to Julia by Lars Hellemo (May 2014)
        - 
        - function checkBounds2d( point, Isize)
        0     if (point[1] < 1) || (point[2] < 1) || (point[1] > (Isize[1])) || (point[2] > (Isize[2]))
        0         return false
        -     end
        0     return true
        - end
        - 
        - function interpgrad2d!(Ireturn::AbstractArray{T},I, Isize, point) where T
        -     #  Linear interpolation variables
  1422528     perc = zeros(T,4,)
  1572480     index = fill(4,4,1)
        0     fTlocalx = floor(point[1])
        0     fTlocaly = floor(point[2])
        0     xBas0 = Int(fTlocalx)
        0     yBas0 = Int(fTlocaly)
        0     xBas1 = xBas0 + 1
        0     yBas1 = yBas0 + 1
        - 
        -     # Linear interpolation constants (percentages)
        0     xCom = point[1] - fTlocalx
        0     yCom = point[2] - fTlocaly
        0     xComi = (1 - xCom)
        0     yComi = (1 - yCom)
        0     perc[1] = xComi * yComi
        0     perc[2] = xComi * yCom
        0     perc[3] = xCom * yComi
        0     perc[4] = xCom * yCom
        - 
        -     # Stick to boundary
        0     if xBas0 < 1
        -         xBas0 = 1
        0         if xBas1 < 1
        -             xBas1 = 1
        -         end
        -     end
        - 
        0     if yBas0 < 1
        -         yBas0 = 1
        0         if yBas1 < 1
        -             yBas1 = 1
        -         end
        -     end
        0     if xBas1 > Isize[1]
        0         xBas1 = Isize[1]
        0         if xBas0 > Isize[1]
        0             xBas0 = Isize[1]
        -         end
        -     end
        - 
        0     if yBas1 > Isize[2]
        0         yBas1 = Isize[2]
        0         if yBas0 > Isize[2]
        0             yBas0 = Isize[2]
        -         end
        -     end
        - 
        -     # Get the neighbour intensities
        0     index[1] = LinearIndices(size(I))[xBas0,yBas0,1] #TODO Why is this dim 3,3,2?
        0     index[2] = LinearIndices(size(I))[xBas0,yBas1,1]
        0     index[3] = LinearIndices(size(I))[xBas1,yBas0,1]
        0     index[4] = LinearIndices(size(I))[xBas1,yBas1,1]
        - 
        0     f = Isize[1] * Isize[2]
        - 
        -     # the interpolated color
        0     Ireturn[1] = sum(I[index[i]] * perc[i] for i=1:4)
        0     Ireturn[2] = sum(I[index[i] + f] * perc[i] for i=1:4) 
        0     return Ireturn
        - end
        - 
        - """
        -     Perform the RK4 raytracing step
        - """
        - function rk4(startpoint::AbstractArray{T}, gradientvolume::AbstractArray{T}, stepsize::Number) where T
        -     gradientarray = gradientvolume # TODO Test if this works (without copy)
   393120     gradientarraysize = collect(size(gradientarray))
        -     nextpoint = startpoint
   336960     nextPoint =  rk4step2d(gradientarray, startpoint, ones(T,2,), stepsize)
        0     return nextPoint
        - end
        - 
        - """
        - Deprecated name for rk4step2d
        -     """
        - function RK4STEP_2D(gradientArray::AbstractArray{T}, startPoint::AbstractArray{T}, nextPoint,stepSize) where T
        -     rk4step2d(gradientArray, startPoint, nextPoint, stepSize)
        - end
        - @deprecate RK4STEP_2D(gradientArray, startPoint, nextPoint, stepSize) rk4step2d(gradientarray, startpoint, nextpoint, stepsize)
        - """
        -     Perform one step of the RK4 algorithm
        - """
        - function rk4step2d(gradientarray::AbstractArray{T}, startpoint::AbstractArray{T}, nextpoint, stepsize) where T
   411584     k = ones(T,4,2)
   336960     temppoint = ones(T,2)
   393120     gradientarraysize = collect(size(gradientarray))
        - 
        -     # Calculate k1:k4
        0     for ki = 1:4
        0         @views interpgrad2d!(k[ki,:], gradientarray, gradientarraysize, startpoint)
        0         @views tempnorm = max(norm(k[ki,:]),1e-6)
        0         for p = 1:2
        0             k[ki,p] *= stepsize/tempnorm
        0             temppoint[p] = startpoint[p] - k[ki,p] * 0.5
        -         end
        -         # Check if still inside the domain
        0         if !checkBounds2d(temppoint, gradientarraysize)
        0             return ones(2,)
        -         end
        -     end
        -     
        -     # Calculate final point
        0     for p = 1:2
        0         nextpoint[p] = startpoint[p] - (k[1,p] + k[2,p] * 2.0 + k[3,p] * 2.0 + k[4,p])/6.0
        -     end
        - 
        -     # Set step to step size
        -     # D1 = nextPoint[1] - startPoint[1]
        -     # D2 = nextPoint[2] - startPoint[2]
        -     # dl = stepSize/(sqrt(D1 * D1 + D2 * D2)+1e-15)
        -     # D1 *= dl
        -     # D2 *= dl
        -     # nextPoint[1] = startPoint[1] + D1
        -     # nextPoint[2] = startPoint[2] + D2
        - 
        -     # Check the if are still inside the domain
        0     if !checkBounds2d(nextpoint, gradientarraysize)
        0         return ones(2,)
        -     end
        0     return nextpoint
        - end
