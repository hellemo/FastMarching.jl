        - """
        - 	msfm()
        - 	
        - 	Calculate the shortest distance from a list of
        - 	points to all other pixels in an image, using the
        - 	Multistencil Fast Marching Method (MSFM). 
        - 	
        - 	This method gives more accurate
        - 	distances by using second order derivatives and cross neighbours.
        - 	
        - 	T=msfm2d(F, SourcePoints, UseSecond, UseCross)
        - 	
        - 	# inputs,
        - 	  F: The speed image. The speed function must always be larger
        - 				than zero (min value 1e-8), otherwise some regions will
        - 				never be reached because the time will go to infinity.
        - 	  SourcePoints : A list of starting points [2 x N] (distance zero)
        - 	  UseSecond : Boolean Set to true if not only first but also second
        - 	               order derivatives are used (default)
        - 	  UseCross : Boolean Set to true if also cross neighbours
        - 	               are used (default)
        - 	# outputs
        - 	  T : Image with distance from SourcePoints to all pixels	
        - """
        - function msfm(speedimage::AbstractArray{T,2}, SourcePointsIn::AbstractArray{T}, usesecond::Bool=true, usecross::Bool=true,Ed=false::Bool) where T
        - 
  1448896 	distanceimage = zeros(T,size(speedimage))
        0 	fill!(distanceimage,T(-Inf))
        - 	# Augmented Fast Marching (For skeletonize)
        - 	
        - 	# Euclidian distance image
        0 	if(Ed)
        0 		Y = zeros(T,size(speedimage))
        - 	end
        - 
        - 	# Pixels which are processed and have a final distance are frozen
    27200 	Frozen   = falses(size(speedimage));
        - 
        - 	# Free memory to store neighbours of the (segmented) region
        0 	neg_free = length(speedimage)
        - 	neg_pos = 0
        0 	if Ed
        0 		neg_list = zeros(T,4,neg_free)
        - 	else
  4341952         neg_list = zeros(T,3,neg_free)
  1453408         neg_list_x = zeros(Int64, neg_free) # was neg_list[2,:]
  1453408         neg_list_y = zeros(Int64, neg_free) # was neg_list[3,:]
        - 	end
        - 
        - 	# (There are 3 pixel classes:
        - 	#   - frozen (processed)
        - 	#   - narrow band (boundary) (in list to check for the next pixel with smallest distance)
        - 	#   - far (not yet used)
        - 
        -  	# Neighbours
        0 	ne = [-1  0;
        - 		   1  0;
        - 		   0 -1;
        - 		   0  1]
        - 
        - 	# SourcePoints = Int.(floor.(SourcePointsIn))
        - 	SourcePoints = SourcePointsIn
        - 
        - 	# set all starting points to distance zero and frozen
        0 	for z = 1:size(SourcePoints,2)
        - 		# starting point
        0 		x = Int(round(SourcePoints[1,z]))
        0 		y = Int(round(SourcePoints[2,z]))
        - 		# Set starting point to frozen and distance to zero
        0 		Frozen[x,y] = true
        0 		distanceimage[x,y] = 0
        - 	end
        - 
        - 
        - 	# Add all neighbours of the starting points to narrow list
        0 	for z = 1:size(SourcePoints,2)
        - 		# starting point
        0 		x = Int(round(SourcePoints[1,z]))
        0 		y = Int(round(SourcePoints[2,z]))
        0 		for k=1:4
        - 			# Location of neighbour
        0 			i = x + ne[k,1]
        0 			j = y + ne[k,2]
        - 			# Check if current neighbour is not yet frozen and inside the
        - 			# picture
        0 			if( (i>0) && (j>0) && (i<=size(speedimage,1)) && (j<=size(speedimage,2)) && (~Frozen[i,j]))
        0 				Tt = 1/max(speedimage[i,j],eps(T))
        - 				Ty = T(1)
        - 				# Update distance in neighbour list or add to neighbour list
        0 				if distanceimage[i,j] > 0
        0 					if neg_list[1,distanceimage[i,j]] > Tt
        - 						neg_list[1,distanceimage[i,j]] = Tt
        - 					end
        - 					if Ed
        - 						neg_list[4,distanceimage[i,j]] = min(Ty, neg_list[4,distanceimage[i,j]]);
        - 					end
        - 				else
        0 					neg_pos=neg_pos+1
        - 					# If running out of memory at a new block
        0 					if neg_pos>neg_free
        0 						neg_free = neg_free * 2
        0 						if Ed
        0 							neg_list = hcat(neg_list, zeros(T,4,neg_free))
        - 						else
        0 							neg_list = hcat(neg_list, zeros(T,3,neg_free))
        - 						end
        - 					end
        0 					if Ed
        0 						@views neg_list[:,neg_pos] = [Tt; i; j; Ty]
        - 					else
    17280 						@views neg_list[:,neg_pos] = [Tt; i; j]
        - 					end
        0 					distanceimage[i,j] = neg_pos
        - 				end
        - 			end
        - 		end
        - 	end
        - 
        - 	# Reuse variables:
     6816 	Tpatch = zeros(T, 5, 5)
     3072 	Order = zeros(Int8, 1, 4)
     3264 	Tm = zeros(T,1,4)
     3264 	Tm2 = zeros(T,1,4)
     3264 	Coeff = zeros(T,3)
     3072 	TT = zeros(T,2)
     3072 	TT2 = zeros(T,2)
        - 	
        - 	# Loop through all pixels of the image
        0 	for itt = 1:length(speedimage)
        - 		# Get the pixel from narrow list (boundary list) with smallest
        - 		# distance value and set it to current pixel location
        - 
        0 		if neg_pos == 0
        - 			break
        - 		end
        0 		(t,index) = findmin(neg_list[1,1:neg_pos])
        0 		x = neg_list_x[index]#round(Int,neg_list[2,index])
        0 		y = neg_list_y[index]#round(Int,neg_list[3,index])
        0 		Frozen[x, y] = true
        0 		distanceimage[x,y] = neg_list[1,index]
        - 
        0 		if Ed
        0 			Y[x,y] = neg_list[4,index]
        - 		end
        - 
        - 		# Remove min value by replacing it with the last value in the array
        0 		if index < neg_pos
        0 			@views neg_list[:,index] = neg_list[:,neg_pos]
        0 			x2 = neg_list_x[index]#round(Int,neg_list[2,index])
        0 			y2 = neg_list_y[index]#round(Int,neg_list[3,index])
        0 			distanceimage[x2,y2] = index
        - 		end
        0 		neg_pos = neg_pos-1
        - 		# Loop through all 4 neighbours of current pixel
        0 		for k = 1:4
        - 			# Location of neighbour
        0 			i = x + ne[k,1]
        0 			j = y + ne[k,2]
        - 
        - 			# Check if current neighbour is not yet frozen and inside the
        - 			# picture
        0 			if (i>0) && (j>0) && (i<=size(speedimage,1)) && (j<= size(speedimage,2)) && (~Frozen[i,j])
        - 
        0 				Tt = calculatedistance!(distanceimage, Tpatch, Order, Coeff, Tm, Tm2, TT, TT2,speedimage[i,j], size(speedimage), i, j, usesecond, usecross, Frozen)
        0 				if Ed
        0 					Ty = calculatedistance!(Y, Tpatch, Order, Coeff, Tm, Tm2, TT, TT2, speedimage[i,j], size(speedimage), i, j, usesecond, usecross, Frozen)
        - 				end
        - 
        - 				# Update distance in neighbour list or add to neighbour list
        0 				if distanceimage[i,j]>0
        0 					if Tt !== nothing
        0 						neg_list[1,round(Int,distanceimage[i,j])] = min(Tt, neg_list[1,round(Int,distanceimage[i,j])] )
        - 					end
        0 					if Ed && (Tt !== nothing)
        0 						neg_list[4,round(Int,distanceimage[i,j])] = min(Ty,neg_list[4,round(Int,distanceimage[i,j])])
        - 					end
        - 				else
        0 					neg_pos = neg_pos + 1
        - 					# If running out of memory at a new block
        0 					if neg_pos > neg_free
        0 						neg_free = neg_free * 2
        0 						if Ed
        0 							neg_list = hcat(neg_list,zeros(T,4,neg_free))
        - 						else
        0 							neg_list = hcat(neg_list,zeros(T,3,neg_free))
        - 						end
        - 					end
        0 					neg_list[1,neg_pos] = Tt
        0 					neg_list_x[neg_pos] = i#neg_list[2,neg_pos] = i
        0 					neg_list_y[neg_pos] = j#neg_list[3,neg_pos] = j
        0 					if Ed
        0 						neg_list[4,neg_pos] = Ty
        - 					end
        0 					distanceimage[i,j] = neg_pos
        - 				end
        - 			end
        - 		end
        - 	end
        0 	return distanceimage
        - end # End function msfm
        - 
        - function calculatedistance(TI::AbstractArray{T}, Fij, sizeF, i, j, usesecond, usecross, Frozen) where T
        - 	Tpatch = zeros(T, 5, 5)
        - 	Order = zeros(Int8, 1, 4)
        - 	Tm = zeros(T,1,4)
        - 	Tm2 = zeros(T,1,4)
        - 	Coeff = zeros(T,3)
        - 	TT = zeros(T,2)
        - 	TT2 = zeros(T,2)
        - 	calculatedistance!(TI, Tpatch, Order, Coeff, Tm, Tm2, TT, TT2, Fij, sizeF, i, j, usesecond, usecross, Frozen)
        - end
        - 
        - 
        - function calculatedistance!(TI::AbstractArray{T}, Tpatch, Order, Coeff, Tm, Tm2, TT, TT2, Fij, sizeF, i, j, usesecond, usecross, Frozen) where T
        - 	
        0 	fill!(Tpatch,T(Inf))
        0 	for nx = -2:2
        0 		for ny = -2:2
        0 			i_n = i + nx
        0 			j_n = j + ny
        0 			if i_n > 0 && j_n > 0 && i_n <= sizeF[1] && j_n <= sizeF[2] && Frozen[i_n, j_n]
        0 				Tpatch[nx+3, ny+3] = TI[i_n, j_n]
        - 			end
        - 		end
        - 	end
        - 
        - 	# The values in order is 0 if no neighbours in that direction
        - 	# 1 if 1e order derivatives is used and 2 if second order
        - 	# derivatives are used
        0 	fill!(Order,0)
        - 
        - 	# Make 1e order derivatives in x and y direction
        0 	fill!(Tm,0)
        0 	Tm[1] = min(Tpatch[2,3], Tpatch[4,3] )
        0 	if isfinite(Tm[1])
        0 		Order[1]=1
        - 	end
        - 
        0 	Tm[2] = min(Tpatch[3,2], Tpatch[3,4])
        0 	if isfinite(Tm[2])	
        0 		Order[2]=1
        - 	end
        - 
        - 	# Make 1e order derivatives in cross directions
        0 	if usecross
        0 		Tm[3] = min(Tpatch[2,2], Tpatch[4,4])
        0 		if isfinite(Tm[3])
        0 			Order[3]=1
        - 		end
        0 		Tm[4] = min(Tpatch[2,4], Tpatch[4,2])
        0 		if isfinite(Tm[4])
        0 			Order[4]=1
        - 		end
        - 	end
        - 
        - 	# Make 2e order derivatives
        0 	if usesecond
        0 		fill!(Tm2,0)
        - 		# pixels with a pixeldistance 2 from the center must be
        - 		# lower in value otherwise use other side or first order
        0 		ch1 = (Tpatch[1,3] < Tpatch[2,3]) && isfinite(Tpatch[2,3])
        0 		ch2 = (Tpatch[5,3] < Tpatch[4,3]) && isfinite(Tpatch[4,3])
        - 
        0 		if ch1 && ch2
        0 			Tm2[1] = min( (4*Tpatch[2,3] - Tpatch[1,3])/3 , (4*Tpatch[4,3] - Tpatch[5,3])/3 )
        0 			Order[1] = 2
        0 		elseif ch1
        0 			Tm2[1] = (4*Tpatch[2,3] - Tpatch[1,3])/3
        0 			Order[1] = 2
        0 		elseif ch2
        0 			Tm2[1] =(4*Tpatch[4,3] - Tpatch[5,3])/3
        0 			Order[1] = 2
        - 		end
        - 
        0 		ch1 = (Tpatch[3,1] < Tpatch[3,2]) && isfinite(Tpatch[3,2])
        0 		ch2 = (Tpatch[3,5] < Tpatch[3,4]) && isfinite(Tpatch[3,4])
        - 
        0 		if ch1 && ch2
        0 			Tm2[2] = min( (4*Tpatch[3,2] - Tpatch[3,1])/3 , (4*Tpatch[3,4] - Tpatch[3,5])/3)
        0 			Order[2] = 2
        0 		elseif ch1
        0 			Tm2[2] = (4*Tpatch[3,2] - Tpatch[3,1])/3
        0 			Order[2] = 2
        0 		elseif ch2
        0 			Tm2[2] = (4*Tpatch[3,4] - Tpatch[3,5])/3
        0 			Order[2] = 2
        - 		end
        - 
        0 		if usecross
        0 			ch1 = (Tpatch[1,1] < Tpatch[2,2]) && isfinite(Tpatch[2,2])
        0 			ch2 = (Tpatch[5,5] < Tpatch[4,4]) && isfinite(Tpatch[4,4])
        0 			if ch1 && ch2
        0 				Tm2[3] = min( (4*Tpatch[2,2] - Tpatch[1,1])/3, (4*Tpatch[4,4] - Tpatch[5,5])/3)
        0 				Order[3] = 2
        0 			elseif ch1
        0 				Tm2[3] = (4*Tpatch[2,2] - Tpatch[1,1])/3
        0 				Order[3] = 2
        0 			elseif ch2
        0 				Tm2[3] = (4*Tpatch[4,4] - Tpatch[5,5])/3
        0 				Order[3] = 2
        - 			end
        - 
        0 			ch1 = (Tpatch[1,5] < Tpatch[2,4]) && isfinite(Tpatch[2,4])
        0 			ch2 = (Tpatch[5,1] < Tpatch[4,2]) && isfinite(Tpatch[4,2])
        0 			if ch1 && ch2
        0 				Tm2[4] = min( (4*Tpatch[2,4] - Tpatch[1,5])/3, (4*Tpatch[4,2] - Tpatch[5,1])/3)
        0 				Order[4] = 2
        0 			elseif ch1
        0 				Tm2[4] = (4*Tpatch[2,4] - Tpatch[1,5])/3
        0 				Order[4] = 2
        0 			elseif ch2
        0 				Tm2[4] = (4*Tpatch[4,2] - Tpatch[5,1])/3
        0 				Order[4] = 2
        - 			end
        - 		end
        - 	else
        0 		fill!(Tm2,0)
        - 	end
        - 
        - 	# Calculate the distance using x and y direction
        0 	Coeff .= (0, 0, -1/(max(Fij^2,eps(T))))
        0 	for t = 1:2
        0 		if Order[t] == 1
        0 			Coeff .+= (1, -2*Tm[t], Tm[t]^2)
        0 		elseif Order[t] == 2
        0 			Coeff .+= (1, -2*Tm2[t], Tm2[t]^2) .* 2.25
        - 		end
        - 	end
        - 
        0 	roots!(TT,Coeff)
        - 	# Calculate the distance using the cross directions
        0 	if usecross
        0 		Coeff .+= (0, 0, -1/(maximum((Fij^2,eps(T)))))
        0 		for t=3:4
        0 			if Order[t] == 1
        0 				Coeff .+= 0.5 .* (1, -2*Tm[t], Tm[t]^2)
        0 			elseif Order[t] == 2
        0 				Coeff .+= 0.5 .* (1, -2*Tm2[t], Tm2[t]^2) .* 2.25
        - 			end
        - 		end
        0 		roots!(TT2, Coeff)
        - 		# Select minimum distance value of both stensils
        0 		if ~isempty(TT2)
        0 			TT = min(maximum(TT), maximum(TT2))
        - 		end
        - 	else
        0 		TT = maximum(TT)
        - 	end
        - 
        - 	# Upwind condition check, current distance must be larger
        - 	# then direct neighbours used in solution
        - 	#DirectNeigbInSol=Tm(isfinite(Tm));
        - 	#if(nnz(DirectNeigbInSol>=Tt)>0) # Will this ever happen?
        - 	#    Tt=min(DirectNeigbInSol)+(1/(max(Fij,eps)));
        - 	#end
        - end
        - 
        - function roots!(z, Coeff::AbstractArray{T}) where T
        0 	a = Coeff[1]
        0 	b = Coeff[2]
        0 	c = Coeff[3]
        0 	d = max((b*b)-4.0*a*c,zero(T))
        0 	if a != 0
        0 		z[1] = (-b - sqrt(d)) / (T(2.0)*a)
        0 		z[2] = (-b + sqrt(d)) / (T(2.0)*a)
        - 	else
        0 		z[1] = (T(2.0)*c)/(-b - sqrt(d))
        0 		z[2] = (T(2.0)*c)/(-b + sqrt(d))
        - 	end
        - end
        - 
        - function roots_exp!(z, Coeff::AbstractArray{T}) where T
        - 	a = Coeff[1]
        - 	b = Coeff[2]
        - 	c = Coeff[3]
        - 	d = max((b*b)-4.0*a*c,zero(T))
        - 	if a != 0
        - 		z = max( (-b - sqrt(d)) / (T(2.0)*a), (-b + sqrt(d)) / (T(2.0)*a) )
        - 	else
        - 		z = max( (T(2.0)*c)/(-b - sqrt(d)), (T(2.0)*c)/(-b + sqrt(d)) )
        - 	end
        - end
        - 
        - function roots(Coeff::AbstractArray{T}) where T
        - 	z = zeros(T,2,1)
        - 	roots!(z,Coeff)
        - 	return z
        - end
